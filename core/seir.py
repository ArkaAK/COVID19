# -*- coding: utf-8 -*-
"""epidemic_calculator_merger.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10UVR-rBep0fJV-31Ndb2G4Uq2orDczGt
"""
import random
import plotly.graph_objects as go
import numpy as np
from operator import itemgetter
import json

import _pickle as cPickle

from core.scrap import states
from visuals.layouts import get_bar_layout



intervention1 = ''',"nodal_param_change":[{"intervention_day":70,"rate_frac":[0.3,0.3,0.3,0.3]}]}'''
intervention2 = ''',"nodal_param_change":[{"intervention_day":140,"delI":[0,12000,20000,30]}]}'''
random_interventions = [intervention1,intervention2]
city_json = list(states.apply(lambda x :  "{" + '''"pop":{},"t0":{},"city":"{}"'''.format(x.Population,x.TNaught,x.States),axis=1 ))
city_with_intervention = [node+random.choice(random_interventions) for node in city_json]
node_json_list =  [json.loads(node_json) for node_json in city_with_intervention]




# Merge_dict dunction is for combining the global and local interventions
def merge_dict(param,a):
    test_list=param+a
    if len(test_list)!=0:
        res_list = []
        final=[]
        for i in range(len(test_list)):
            if test_list[i] not in test_list[i + 1:] and test_list[i].keys()!=0:
                res_list.append(test_list[i])
        newlist = sorted(res_list, key=lambda k: k['intervention_day'])
        i,j=0,1
        while i<len(newlist) and j<len(newlist):
            if newlist[i]['intervention_day']==newlist[j]['intervention_day'] and i!=j:
                newlist[i].update(newlist[j])
                newlist.remove(newlist[j])
            else:
                i+=1
        return newlist
    else:
        return test_list




def dfdt(f,D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR, rate):
    S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal=f[0],f[1],f[2],f[3],f[4],f[5],f[6],f[7],f[8],f[9],f[10]
    beta  = rate/(D_infectious)
    a     = 1/D_incubation
    gamma = 1/D_infectious

    p_severe = P_SEVERE
    p_fatal  = CFR
    p_mild   = 1 - P_SEVERE - CFR

    dS        = -S*np.dot(beta,I)
    dE        =  S*np.dot(beta,I) - a*E
    dI        =  a*E - gamma*I
    dR        =  gamma*I
    dMild     =  p_mild*gamma*I   - (1/D_recovery_mild)*Mild
    dSevere   =  p_severe*gamma*I - (1/D_hospital_lag)*Severe
    dSevere_H =  (1/D_hospital_lag)*Severe - (1/D_recovery_severe)*Severe_H
    dFatal    =  p_fatal*gamma*I  - (1/D_death)*Fatal
    dR_Mild   =  (1/D_recovery_mild)*Mild
    dR_Severe =  (1/D_recovery_severe)*Severe_H
    dR_Fatal  =  (1/D_death)*Fatal
    return np.array([dS,dE,dI,dR,dMild,dSevere,dSevere_H,dFatal,dR_Mild,dR_Severe,dR_Fatal])


def rungeKutta(dfdt,f0,D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR, pop, rate, t0, t, n=20, dt=1):
    # n = Count number of iterations using step size  or
    # step height h
    h = dt/n
    n=int((t-t0)/h)
    # Iterate for number of iterations
    f0=np.array(f0)
    f=f0/pop
    T,S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal=[],[],[],[],[],[],[],[],[],[],[],[]
    for iteration in range(1, n + 1):

        "Apply Runge Kutta Formulas to find next value of y"
        k1 = h * dfdt(f,D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR,rate)
        k2 = h * dfdt(f+0.5*k1,D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR,rate)
        k3 = h * dfdt(f+0.5*k2,D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR,rate)
        k4 = h * dfdt(f+k3,D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR,rate)

        # Update next value of y
        f = f + (1.0 / 6.0)*(k1 + 2 * k2 + 2 * k3 + k4)
        # Update next value of x
        t0 = t0 + h

        if iteration%20==0:
            T.append((t0))
            S.append((f[0]*pop))
            E.append((f[1]*pop))
            I.append((f[2]*pop))
            R.append((f[3]*pop))
            Mild.append((f[4]*pop))
            Severe.append((f[5]*pop))
            Severe_H.append((f[6]*pop))
            Fatal.append((f[7]*pop))
            R_Mild.append((f[8]*pop))
            R_Severe.append((f[9]*pop))
            R_Fatal.append((f[10]*pop))
    return T,S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal

# Age_sum takes an input of list of numpy arrays, and gives an output of numpy array with the sum of all age groups
def age_sum(list):
    new=[]
    for i in list:
        Sum=np.sum(i)
        new.append(Sum)
    return np.array(new)

def getSolution(dfdt,days,group):
    # Group is a config dictionary of one given node
    # days is the global duration
    global pop,t0,no_of_age_groups,pop_frac,D_incubation,D_infectious,I0,R0,E0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0, \
        D_death,P_SEVERE,D_hospital_lag,D_recovery_severe, \
        D_recovery_mild,CFR,rates,param_list,S0,delI,delS,delE,delR,rate_frac,intervention_day

    pop,t0,no_of_age_groups,pop_frac,D_incubation,D_infectious,I0,R0,E0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0, \
    D_death,P_SEVERE,D_hospital_lag,D_recovery_severe, \
    D_recovery_mild,CFR,rates,param_list,nodal_param_change,S0,delI,delS,delE,delR,rate_frac,intervention_day= itemgetter("pop","t0","no_of_age_groups","pop_frac","D_incubation","D_infectious","I0","R0","E0","Mild0","Severe0","Severe_H0", \
                                                                                                                          "Fatal0","R_Mild0","R_Severe0","R_Fatal0","D_death","P_SEVERE","D_hospital_lag", \
                                                                                                                          "D_recovery_severe","D_recovery_mild","CFR","rates","param","nodal_param_change","S0","delI","delS","delE","delR","rate_frac","intervention_day")(group)
    pop=pop*pop_frac

    if t0==0:
        T,S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal=[],[],[],[],[],[],[],[],[],[],[],[]
    else:
        T,S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal=list(np.arange(t0)+1),[np.array(pop)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0,[np.array([0]*no_of_age_groups)]*t0

    # If S0 is negative, the value of S) array will be calculated from pop,E0,I0,R0
    if np.sum(S0)<=0:
        S0=pop-E0-I0-R0
    try:
        param_list=merge_dict(param_list,nodal_param_change)
    except:
        pass

    if len(param_list)!=0:
        for index in range(0,len(param_list)):
            if index>0 :
                t0=intervention_day
            # S,E,I,R,... are list of numpy arrays
            T0,S0,E0,I0,R0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0=rungeKutta(dfdt,[S0,E0,I0,R0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0],D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR, pop, rates, t0, param_list[index]['intervention_day'])
            T,S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal,=T+T0,S+S0,E+E0,I+I0,R+R0,Mild+Mild0,Severe+Severe0,Severe_H+Severe_H0,Fatal+Fatal0,R_Mild+R_Mild0,R_Severe+R_Severe0,R_Fatal+R_Fatal0
            delI,delS,delE,delR,rate_frac,rates=itemgetter("delI","delS","delE","delR","rate_frac","rates")(group)
            globals().update(param_list[index])
            T0,S0,E0,I0,R0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0=T[-1],S[-1],E[-1],I[-1],R[-1],Mild[-1],Severe[-1],Severe_H[-1],Fatal[-1],R_Mild[-1],R_Severe[-1],R_Fatal[-1]
            I0,S0,E0,R0,rates=I0+delI,S0+delS,E0+delE,R0+delR,rates*np.reshape(rate_frac,[no_of_age_groups,1])
            # print(delI,delS,delE,delR,rate_frac,rates)

    if intervention_day< days:
        T0,S0,E0,I0,R0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0=rungeKutta(dfdt,[S0,E0,I0,R0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0],D_incubation, D_infectious, D_recovery_mild, D_hospital_lag, D_recovery_severe, D_death, P_SEVERE, CFR, pop, rates, intervention_day, days)
        T,S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal=T+T0,S+S0,E+E0,I+I0,R+R0,Mild+Mild0,Severe+Severe0,Severe_H+Severe_H0,Fatal+Fatal0,R_Mild+R_Mild0,R_Severe+R_Severe0,R_Fatal+R_Fatal0

    return S[:days],E[:days],I[:days],R[:days],Mild[:days],Severe[:days],Severe_H[:days],Fatal[:days],R_Mild[:days],R_Severe[:days],R_Fatal[:days],param_list


def plot_graph(T, S, E, I, R, Mild, Severe, Severe_H, Fatal, R_Mild, R_Severe, R_Fatal, interventions, days, t0, city):
    ht = '''%{fullData.name}	<br> &#931; :%{y:}<br> &#916;: %{text}<br> Day :%{x:} <extra></extra>'''
    trace1 = go.Bar(x=T[:days], y=E[:days], name='Exposed &nbsp; &nbsp; ', text=np.diff(E[:days]),
                    marker=dict(color='rgb(253,192,134,0.2)'), hovertemplate=ht)
    trace2 = go.Bar(x=T[:days], y=I[:days], name='Infectious &nbsp; &nbsp;', text=np.diff(I[:days]),
                    marker=dict(color='rgb(240,2,127,0.2)'), hovertemplate=ht)
    trace3 = go.Bar(x=T[:days], y=Severe_H[:days], name='Hospitalized', text=np.diff(Severe_H[:days]),
                    marker=dict(color='rgb(141,160,203,0.2)'), hovertemplate=ht)
    trace4 = go.Bar(x=T[:days], y=R_Fatal[:days], name='Fatalities &nbsp; &nbsp; &nbsp;', text=np.diff(R_Fatal[:days]),
                    marker=dict(color='rgb(56,108,176,0.2)'), hovertemplate=ht)

    data = [trace1, trace2, trace3, trace4]
    if city != "India":
        for intervention in interventions:
            hover_text = ""
            for key, value in intervention.items():
                hover_text += str(key) + ' : ' + str(value) + '<br>'
            it = go.Scatter(y=[0, (max(E) + max(I) + max(Severe_H) + max(R_Fatal))],
                            x=[intervention["intervention_day"], intervention["intervention_day"]],
                            mode='lines',
                            showlegend=False,
                            text=hover_text,
                            hoverinfo="text")
            data.append(it)

    layout = get_bar_layout(city)

    return {"data": data[::-1], "layout": layout}


def epidemic_calculator(Config,days):
    S0,E0,I0,R0,Mild0,Severe0,Severe_H0,Fatal0,R_Mild0,R_Severe0,R_Fatal0,intervention  =   getSolution(dfdt,days,Config)
    S,E,I,R,Mild,Severe,Severe_H,Fatal,R_Mild,R_Severe,R_Fatal  = age_sum(S0),age_sum(E0),age_sum(I0),age_sum(R0),age_sum(Mild0),age_sum(Severe0),age_sum(Severe_H0),age_sum(Fatal0),age_sum(R_Mild0),age_sum(R_Severe0),age_sum(R_Fatal0)
    return np.array(S[:days]),np.array(E[:days]),np.array(I[:days]),np.array(R[:days]),np.array(Mild[:days]),np.array(Severe[:days]),np.array(Severe_H[:days]),np.array(Fatal[:days]),np.array(R_Mild[:days]),np.array(R_Severe[:days]),np.array(R_Fatal[:days]),intervention

class GlobalConfig:
    def __init__(self, pop=7000000,
                 t0=0,
                 no_of_age_groups=4,
                 D_incubation=5.2,
                 D_infectious=2.9,
                 intervention_day = 0,
                 S0=-1,                 # Put S0 = -1 if not adding value explicitely . Then S0 = Pop -I0-R0-E0
                 I0=1,
                 R0=0,
                 E0=0,
                 rate_frac=1,
                 delI=0,
                 delS=0,
                 delR=0,
                 delE=0,
                 Mild0=0,
                 Severe0=0,
                 Severe_H0=0,
                 Fatal0=0,
                 R_Mild0=0,
                 R_Severe0=0,
                 R_Fatal0=0,
                 D_death=32,
                 D_hospital_lag=5,
                 D_recovery_severe=28.6,
                 D_recovery_mild=11.1,
                 pop_frac=np.array([0.3,0.3,0.25,0.15]),
                 CFR=np.array([0.001,0.005,0.03,0.07]),
                 P_SEVERE=np.array([0.05,0.1,0.2,0.5]),
                 r1 = 3.6,
                 r2 = 2.4,
                 r3 = 1.5,
                 r4 = 0.6,
                 #  param =[{"intervention_day":70,"rate_frac":np.array([0,1,1,0])}],
                 param=[],
                 nodal_param_change=[],
                 ):

        self.pop = pop
        self.t0 = t0
        self.no_of_age_groups=no_of_age_groups
        self.pop_frac = pop_frac
        self.rates = np.array([[r1, r2, r3, r4], [r2, r1, r3, r4], [r2, r3, r3, r4], [r4, r4, r4, r4]])*pop_frac
        self.D_incubation = np.array([D_incubation]*no_of_age_groups)
        self.D_infectious = np.array([D_infectious]*no_of_age_groups)
        self.I0 = np.array([I0]*no_of_age_groups)
        self.R0 = np.array([R0]*no_of_age_groups)
        self.E0 = np.array([E0]*no_of_age_groups)
        self.S0 = np.array([S0]*no_of_age_groups)
        self.delI=np.array([delI]*no_of_age_groups)
        self.delR=np.array([delR]*no_of_age_groups)
        self.delS=np.array([delS]*no_of_age_groups)
        self.delE=np.array([delE]*no_of_age_groups)
        self.rate_frac=np.array([rate_frac]*no_of_age_groups)
        self.Mild0 = np.array([Mild0]*no_of_age_groups)
        self.Severe0 = np.array([Severe0]*no_of_age_groups)
        self.Severe_H0 = np.array([Severe_H0]*no_of_age_groups)
        self.Fatal0 = np.array([Fatal0]*no_of_age_groups)
        self.R_Mild0 = np.array([R_Mild0]*no_of_age_groups)
        self.R_Severe0 = np.array([R_Severe0]*no_of_age_groups)
        self.R_Fatal0 = np.array([R_Fatal0]*no_of_age_groups)
        self.D_death = np.array([D_death]*no_of_age_groups)
        self.D_hospital_lag = np.array([D_hospital_lag]*no_of_age_groups)
        self.D_recovery_severe = np.array([D_recovery_severe]*no_of_age_groups)
        self.D_recovery_mild = np.array([D_recovery_mild]*no_of_age_groups)
        self.P_SEVERE = P_SEVERE
        self.CFR = CFR
        self.param = param
        self.intervention_day = intervention_day
        self.nodal_param_change=nodal_param_change


    def instantiate_with_local_config(self, local_config):
        local_config_params = {}
        for key,value in local_config.items():
            if key=='nodal_param_change':
                for dictt in value:
                    for k,v in dictt.items():
                        if k!='intervention_day':
                            v=np.array(v)
            elif type(value)==list:
                value=np.array(value)
            setattr(self, key, value)


class MemoizeMutable:
    def __init__(self, fn):
        self.fn = fn
        self.memo = {}
    def __call__(self, *args, **kwds):
        str = cPickle.dumps(args, 1)+cPickle.dumps(kwds, 1)
        if not str in self.memo:
            self.memo[str] = self.fn(*args, **kwds)
        return self.memo[str]


### todo : when we start using config files to make realtime modification this function must take in the config file or its version as parameter
def unmemoized_network_epidemic_calc(city, days=365):
    S, E, I, R, Mild, Severe, Severe_H, Fatal, R_Mild, R_Severe, R_Fatal = np.array([0] * days), np.array(
        [0] * days), np.array([0] * days), np.array([0] * days), np.array([0] * days), np.array([0] * days), np.array(
        [0] * days), np.array([0] * days), np.array([0] * days), np.array([0] * days), np.array([0] * days)
    if city == "India":
        for local_config in node_json_list:
            # import local params json file to instantiate objects
            E0, Fatal0, I0, Mild0, R0, R_Fatal0, R_Mild0, R_Severe0, S0, Severe0, Severe_H0, intervention, node_config = memoized_get_SEIR(
                days, local_config)
            S, E, I, R, Mild, Severe, Severe_H, Fatal, R_Mild, R_Severe, R_Fatal = S + S0, E + E0, I + I0, R + R0, Mild + Mild0, Severe + Severe0, Severe_H + Severe_H0, Fatal + Fatal0, R_Mild + R_Mild0, R_Severe + R_Severe0, R_Fatal + R_Fatal0
        t0 = 0
    else:
        local_config = next(obj for obj in node_json_list  if obj["city"]==city)
        E, Fatal, I, Mild, R, R_Fatal, R_Mild, R_Severe, S, Severe, Severe_H, intervention, node_config = memoized_get_SEIR(days,
                                                                                                                            local_config)
        t0 = node_config.t0

    return plot_graph(np.arange(days) + 1, S, E, I, R, Mild, Severe, Severe_H, Fatal, R_Mild, R_Severe, R_Fatal,
                      intervention, days, t0, city)


def get_SEIR(days, local_config):
    node_config = GlobalConfig()
    node_config.instantiate_with_local_config(local_config)
    # print('City Config File is as follows: \n', node_config.__dict__)
    S0, E0, I0, R0, Mild0, Severe0, Severe_H0, Fatal0, R_Mild0, R_Severe0, R_Fatal0, intervention = epidemic_calculator(
        node_config.__dict__, days)
    return E0, Fatal0, I0, Mild0, R0, R_Fatal0, R_Mild0, R_Severe0, S0, Severe0, Severe_H0, intervention, node_config


memoized_get_SEIR = MemoizeMutable(get_SEIR)
network_epidemic_calc = MemoizeMutable(unmemoized_network_epidemic_calc)

network_epidemic_calc("India")
